{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./scripts/constants/bitmap-fonts.js","webpack:///./scripts/scenes/loader.js","webpack:///./scripts/scenes/menu.js","webpack:///./scripts/scenes/leaderboard.js","webpack:///./scripts/scenes/game.js","webpack:///./scripts/constants/grid.js","webpack:///./scripts/objects/food.js","webpack:///./scripts/objects/snake.js","webpack:///./scripts/scenes/maze.js","webpack:///./scripts/scenes/scoreboard.js","webpack:///./scripts/scenes/chooseName.js","webpack:///./scripts/config.js","webpack:///./scripts/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","image","width","height","chars","offset","x","y","spacing","charsPerRow","Phaser","Scene","super","this","load","cache","bitmapFont","add","GameObjects","RetroFont","Parse","scene","start","Menu","cameras","main","inputName","document","getElementById","startButton","bitmapText","setOrigin","tween","targets","ease","k","duration","yoyo","repeat","alpha","zone","originX","originY","setInteractive","once","highScore","leaderboardButton","Leaderboard","scores","axios","then","res","data","map","elem","toUpperCase","score","backBtn","stop","Game","points","scoreboard","maze","launch","gameScene","food","addFood","snake","addSnake","cursors","input","keyboard","addKeys","leftKey","Input","Keyboard","KeyCodes","LEFT","rightKey","RIGHT","upKey","UP","downKey","DOWN","time","alive","updateInput","updateLogic","JustDown","turnSnake","update","collideWithFood","updatePoints","reposition","endGame","events","emit","Math","max","post","console","log","delayedCall","WIDTH","HEIGHT","LENGTH","Image","children","testGrid","Array","from","length","updateGrid","validLocations","push","pos","RND","pick","setPosition","Direction","left","right","up","down","body","group","defaultKey","createCallback","head","direction","Geom","Point","directionPath","headPosition","tailPosition","updated","moveTime","moveDelay","move","direct","turnLeft","turnRight","setTo","Actions","GetFirst","entries","Wrap","ShiftPosition","hitBody","grow","grid","segment","getChildren","on","setScore","showGameOver","scoreLabel","gameOverLabel","setVisible","setText","String","ChooseName","nameInput","style","display","submitBtn","zoom","resolution","type","AUTO","pixelArt","transparent","canvasStyle","backgroundColor","physics","default","loader","path","plugins","global","values","boot"],"mappings":"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","file":"app-79c99151685002addf94.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1416);\n","/*\n * `bitmap-fonts`\n * ==============\n *\n * Bitmap fonts definitions.\n */\n\nexport default {\n  image: 'font',\n  width: 16,\n  height: 16,\n  chars: '0123456789   ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  offset: {x: 0, y: 0},\n  spacing: {x: 0, y: 0},\n  charsPerRow: 13\n};\n","import fontConfig from '@/constants/bitmap-fonts';\n\nexport default class Loader extends Phaser.Scene {\n  /**\n   *  Takes care of loading the main game assets.\n   *\n   *  @extends Phaser.Scene\n   */\n  constructor() {\n    super({ key: 'Loader' });\n  }\n\n  /**\n   *  Declare which game assets need to be loaded.\n   *\n   *  @protected\n   */\n  preload() {\n    this.load.image(['body', 'food', 'font', 'frame', 'title']);\n  }\n\n  /**\n   *  Set up and launch the main scene.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  create(/* data */) {\n    //  Register our custom bitmap font in he game system cache.\n    this.cache.bitmapFont.add(\n      fontConfig.image,\n      Phaser.GameObjects.RetroFont.Parse(this, fontConfig)\n    );\n\n    //  We are done here. Launch the game menu.\n    this.scene.start('Menu');\n  }\n}\n","export default class Menu extends Phaser.Scene {\n  /**\n   *  Show the game title and menu.\n   *\n   *  @extends Phaser.Scene\n   */\n  constructor() {\n    super({ key: 'Menu' });\n  }\n\n  /**\n   *  Responsible for setting up the game objects on the screen.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  create(/* data */) {\n    //  Save viewport center coordinates for reference.\n    const x = this.cameras.main.width / 2;\n    const y = this.cameras.main.height / 2;\n\n    let inputName = document.getElementById('snakeName').value;\n    //  Place the Title image above the middle of the screen.\n    this.add.image(x, y - 80, 'title');\n\n    //  Use a bitmap text object as the face of our start button.\n    const startButton = this.add\n      .bitmapText(x, y + 20, 'font', 'START')\n      .setOrigin(0.5, 1);\n\n    //  Apply a blink effect to the button using a custom easing function.\n    this.add.tween({\n      targets: [startButton],\n      ease: k => (k < 0.5 ? 0 : 1),\n      duration: 250,\n      yoyo: true,\n      repeat: -1,\n      alpha: 0\n    });\n\n    //  Handle the click or tap of the button using an input zone slightly\n    //  bigger than the text object.\n    this.add\n      .zone(\n        startButton.x - startButton.width * startButton.originX - 16,\n        startButton.y - startButton.height * startButton.originY - 16,\n        startButton.width + 32,\n        startButton.height + 32\n      )\n      .setOrigin(0, 0)\n      .setInteractive()\n      .once('pointerup', () => {\n        if (inputName) {\n          this.scene.start('Game');\n        } else this.scene.start('ChooseName');\n      });\n\n    this.add.zone();\n\n    //  Get the last game high score.\n    const { highScore } = this.scene.get('Game');\n\n    // Display leaderboard\n    const leaderboardButton = this.add\n      .bitmapText(x, y + 80, 'font', 'LEADERBOARD')\n      .setOrigin(0.5, 2);\n    this.add\n      .zone(\n        leaderboardButton.x -\n          leaderboardButton.width * leaderboardButton.originX -\n          16,\n        leaderboardButton.y -\n          leaderboardButton.height * leaderboardButton.originY -\n          16,\n        leaderboardButton.width + 32,\n        leaderboardButton.height + 32\n      )\n      .setOrigin(0, 0)\n      .setInteractive()\n      .once('pointerup', () => this.scene.start('Leaderboard'));\n\n    this.add.zone();\n    //  Display the registered highest score of the game.\n    this.add\n      .bitmapText(x, y + 100, 'font', `YOUR HIGH SCORE`)\n      .setOrigin(0.5, 1);\n    this.add\n      .bitmapText(x, y + 150, 'font', `${highScore} POINTS`)\n      .setOrigin(0.5, 2);\n  }\n}\n","export default class Leaderboard extends Phaser.Scene {\n  /**\n   *  Show the game title and menu.\n   *\n   *  @extends Phaser.Scene\n   */\n  constructor() {\n    super({ key: 'Leaderboard' });\n  }\n\n  /**\n   *  Responsible for setting up the game objects on the screen.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  create(/* data */) {\n    //  Save viewport center coordinates for reference.\n    const x = this.cameras.main.width / 2;\n    const y = this.cameras.main.height / 2;\n    //  Place the Title image above the middle of the screen.\n    //this.add.image(x, y - 80, 'title')\n\n    let scores;\n    axios\n      .get('https://snake.sneakerindustry.ro:5000/leaderboard')\n      .then(res => {\n        scores = res.data;\n      })\n      .then(data => {\n        scores.map((elem, i) => {\n          this.add\n            .bitmapText(\n              x,\n              y + 20 * i,\n              'font',\n              `${i + 1} ${elem.name.toUpperCase()} ${elem.score}`\n            )\n            .setOrigin(0.5, 10 - i);\n        });\n      });\n\n    const backBtn = this.add.bitmapText(x - 300, y + 160, 'font', 'BACK');\n\n    this.add\n      .zone(\n        backBtn.x - backBtn.width * backBtn.originX - 16,\n        backBtn.y - backBtn.height * backBtn.originY - 16,\n        backBtn.width + 32,\n        backBtn.height + 32\n      )\n      .setOrigin(0, 0)\n      .setInteractive()\n      .once('pointerup', () => {\n        this.scene.stop('Leaderboard');\n        this.scene.start('Menu');\n      });\n  }\n}\n","export default class Game extends Phaser.Scene {\n  /**\n   *  The main game scene. It spawns the other two game scenes in parallel.\n   *  One is the score board, showing the player points and the eventual 'GAME\n   *  OVER' message. The other is the maze where the actual game action\n   *  happens. Player input and game logic updates are handled here.\n   *\n   *  This scene emits two events:\n   *    - `food-eaten`: When a food gets eaten by the snake.\n   *    - `snake-died`: When the snake collides with itself.\n   *\n   *  Those events are used to update the score board.\n   *\n   *  @extends Phaser.Scene\n   */\n  preload() {}\n\n  constructor() {\n    super({ key: 'Game' })\n\n    /**\n     *  Keep the last high score registered.\n     */\n    this.highScore = 0\n  }\n\n  /**\n   *  Called when this scene is initialized.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  init(/* data */) {\n    /**\n     *  Current game score.\n     */\n    this.points = 0\n  }\n\n  /**\n   *  Responsible for setting up game objects on the screen.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  create(/* data */) {\n    //  Put the frame behind the maze.\n    this.add.image(0, 0, 'frame').setOrigin(0, 0)\n\n    //  Get a reference of the scenes to start.\n    const scoreboard = this.scene.get('Scoreboard')\n    const maze = this.scene.get('Maze')\n    const leaderboard = this.scene.get('Leaderboard')\n\n    //  Run both scenes in parallel.\n    this.scene.launch(scoreboard, { gameScene: this }).launch(maze)\n\n    //  Add the game objects to the maze scene.\n    this.food = maze.addFood(3, 4)\n    this.snake = maze.addSnake(8, 8)\n\n    //  Create our keyboard controls.\n    this.cursors = this.input.keyboard.addKeys({\n      leftKey: Phaser.Input.Keyboard.KeyCodes.LEFT,\n      rightKey: Phaser.Input.Keyboard.KeyCodes.RIGHT,\n      upKey: Phaser.Input.Keyboard.KeyCodes.UP,\n      downKey: Phaser.Input.Keyboard.KeyCodes.DOWN\n    })\n  }\n\n  /**\n   *  Handles updates to game logic, physics and game objects.\n   *\n   *  @protected\n   *  @param {number} time - Current internal clock time.\n   *  @param {number} delta - Time elapsed since last update.\n   */\n  update(time) {\n    if (this.snake.alive) {\n      this.updateInput()\n      this.updateLogic(time)\n    }\n  }\n\n  //  ------------------------------------------------------------------------\n\n  /**\n   *  Handles user input.\n   *\n   *  @private\n   */\n  updateInput() {\n    const { leftKey, rightKey, upKey, downKey } = this.cursors\n\n    //  Check which key was just pressed down, then change the direction the\n    //  snake is heading.\n    if (Phaser.Input.Keyboard.JustDown(leftKey)) {\n      this.snake.turnSnake('left')\n    } else if (Phaser.Input.Keyboard.JustDown(rightKey)) {\n      this.snake.turnSnake('right')\n    } else if (Phaser.Input.Keyboard.JustDown(upKey)) {\n      this.snake.turnSnake('up')\n    } else if (Phaser.Input.Keyboard.JustDown(downKey)) {\n      this.snake.turnSnake('down')\n    }\n  }\n\n  /**\n   *  Updates game logic.\n   *\n   *  @private\n   *  @param {number} time - Current internal clock time.\n   */\n  updateLogic(time) {\n    const { food, snake } = this\n\n    if (snake.update(time)) {\n      //  If the snake updated, we need to check for collision against food.\n      if (snake.collideWithFood(food, this.points)) {\n        this.updatePoints()\n        food.reposition(snake)\n      }\n    }\n\n    if (!snake.alive) {\n      this.endGame()\n    }\n  }\n\n  /**\n   *  Announces game over.\n   *\n   *  @private\n   */\n  endGame() {\n    this.events.emit('snake-died')\n\n    //  Update the high score.\n    this.highScore = Math.max(this.points, this.highScore)\n\n    //insert values in DB\n    this.snake.name = document.getElementById('snakeName').value\n    axios\n      .post('https://snake.sneakerindustry.ro:5000/scores', {\n        name: this.snake.name.toUpperCase(),\n        score: this.points\n      })\n      .then(\n        res => console.log('posted')\n        // console.log({\n        //   name: this.snake.name.toUpperCase(),\n        //   score: this.points\n        // })\n      )\n\n    //  Wait for a moment and go back to the menu screen.\n    this.time.delayedCall(2500, () => {\n      this.scene\n        .stop('Scoreboard')\n        .stop('Maze')\n        .stop('Leaderboard')\n        .start('Menu')\n    })\n  }\n\n  /**\n   *  Updates score points.\n   *\n   *  @private\n   */\n  updatePoints() {\n    this.points += 5\n    this.events.emit('food-eaten', this.points)\n  }\n}\n","/*\n * `grid`\n * ======\n *\n * Grid dimensions.\n */\n\n/**\n * The width of the grid.\n */\nexport const WIDTH = 39;\n\n/**\n * The height of the grid.\n */\nexport const HEIGHT = 20;\n\n/**\n * The lenght of each grid unit, in pixels.\n */\nexport const LENGTH = 16;\n","import {WIDTH, HEIGHT, LENGTH} from '@/constants/grid';\n\nexport default class Food extends Phaser.GameObjects.Image {\n  /**\n   *  The food to be eaten by the snake.\n   *\n   *  @param {Phaser.Scene} scene - The scene that owns this image.\n   *  @param {number} x - The horizontal coordinate relative to the scene viewport.\n   *  @param {number} y - The vertical coordinate relative to the scene viewport.\n   *  @extends Phaser.GameObjects.Image\n   */\n  constructor(scene, x, y) {\n    super(scene, x * LENGTH, y * LENGTH, 'food').setOrigin(0);\n\n    scene.children.add(this);\n  }\n\n  /**\n   *  We can place the food anywhere in our grid *except* on-top of the snake,\n   *  so we need to filter those out of the possible food locations. If there\n   *  aren't any locations left, they've won!\n   *\n   *  @public\n   *  @param {Snake} snake - The snake object.\n   *  @returns {boolean} true if the food was placed, otherwise false.\n   */\n  reposition(snake) {\n    //  First, create a grid that assumes all positions are valid for the new\n    //  piece of food.\n    const testGrid = Array.from(\n      {length: HEIGHT},\n      () => Array.from({length: WIDTH}, () => true)\n    );\n\n    snake.updateGrid(testGrid);\n\n    //  Purge out false positions.\n    const validLocations = [];\n\n    for (let y = 0; y < HEIGHT; y++) {\n      for (let x = 0; x < WIDTH; x++) {\n        if (testGrid[y][x] === true) {\n          //  Is this position valid for food? If so, add it here...\n          validLocations.push({x, y});\n        }\n      }\n    }\n\n    if (validLocations.length > 0) {\n      //  Use the RNG to pick a random food position.\n      let pos = Phaser.Math.RND.pick(validLocations);\n\n      //  And place it.\n      this.setPosition(pos.x * LENGTH, pos.y * LENGTH);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n","import { WIDTH, HEIGHT, LENGTH } from '@/constants/grid'\n\nvar Direction = {\n  left: 'left',\n  right: 'right',\n  up: 'up',\n  down: 'down'\n}\n\nvar KeyboardInput = {\n  // Changing the direciton to the corresponding key.\n  CheckDirection: function() {\n    if (cursors.right.isDown && Snake.direction != Direction.left)\n      Snake.direction = Direction.right\n    else if (cursors.left.isDown && Snake.direction != Direction.right)\n      Snake.direction = Direction.left\n    else if (cursors.up.isDown && Snake.direction != Direction.down)\n      Snake.direction = Direction.up\n    else if (cursors.down.isDown && Snake.direction != Direction.up)\n      Snake.direction = Direction.down\n  }\n}\n\nexport default class Snake {\n  /**\n   *  Handles the logic and appearance of the snake in the maze.\n   *\n   *  @param {Phaser.Scene} scene - The scene that owns this object.\n   *  @param {number} x - The horizontal coordinate relative to the scene viewport.\n   *  @param {number} y - The vertical coordinate relative to the scene viewport.\n   */\n  constructor(scene, x, y) {\n    this.body = scene.add.group({\n      defaultKey: 'body',\n      createCallback: o => o.setOrigin(0)\n    })\n\n    this.head = this.body.create(x * LENGTH, y * LENGTH)\n\n    this.direction = new Phaser.Geom.Point(LENGTH, 0)\n    this.directionPath = Direction.right\n    this.headPosition = new Phaser.Geom.Point(0, 0)\n    this.tailPosition = new Phaser.Geom.Point(0, 0)\n\n    this.name = null\n    this.alive = true\n    this.updated = true\n    this.moveTime = 0\n    this.moveDelay = 100\n  }\n\n  /**\n   *  Updates the snake segments in the maze.\n   *\n   *  @public\n   *  @param {number} time - The current game clock value.\n   *  @returns {boolean} Whether the snake updated or not.\n   */\n  update(time) {\n    if (time >= this.moveTime) {\n      this.updated = true\n      return this.move(time)\n    }\n\n    return false\n  }\n\n  /**\n   *  Makes the snake rotate counter clockwise on the next update.\n   *\n   *  @public\n   */\n\n  turnSnake(direct) {\n    if (this.updated) {\n      switch (direct) {\n        case 'left':\n          if (this.directionPath == 'up') this.turnLeft()\n          if (this.directionPath == 'down') this.turnRight()\n          if (this.directionPath == 'left' || this.directionPath == 'right')\n            return\n          this.directionPath = 'left'\n\n          break\n        case 'right':\n          if (this.directionPath == 'up') this.turnRight()\n          if (this.directionPath == 'down') this.turnLeft()\n          if (this.directionPath == 'left' || this.directionPath == 'right')\n            return\n          this.directionPath = 'right'\n          break\n        case 'up':\n          if (this.directionPath == 'left') this.turnRight()\n          if (this.directionPath == 'right') this.turnLeft()\n          if (this.directionPath == 'up' || this.directionPath == 'down') return\n          this.directionPath = 'up'\n          break\n        case 'down':\n          if (this.directionPath == 'left') this.turnLeft()\n          if (this.directionPath == 'right') this.turnRight()\n          if (this.directionPath == 'up' || this.directionPath == 'down') return\n          this.directionPath = 'down'\n      }\n      this.updated = false\n      // console.log(this.directionPath)\n    }\n  }\n\n  turnLeft() {\n    if (this.updated) {\n      this.direction.setTo(this.direction.y, -this.direction.x)\n      this.updated = false\n    }\n  }\n\n  /**\n   *  Makes the snake rotate clockwise on the next update.\n   *\n   *  @public\n   */\n  turnRight() {\n    if (this.updated) {\n      this.direction.setTo(-this.direction.y, this.direction.x)\n      this.updated = false\n    }\n  }\n\n  /**\n   *  Tells whether the snake run over its body or not.\n   *\n   *  @private\n   *  @returns {boolean} True if the snake collided with itself.\n   */\n  hitBody() {\n    return Phaser.Actions.GetFirst(\n      this.body.children.entries,\n      { x: this.head.x, y: this.head.y },\n      1\n    )\n  }\n\n  /**\n   *  Moves the snake segments around the maze.\n   *\n   *  @private\n   *  @param {number} time - The current game clock value.\n   *  @returns {boolean} Whether the snake has moved or not.\n   */\n  move(time) {\n    //  Update the snake position according to the direction the player wants\n    //  it to move to. The `Math.Wrap` function call allows the snake to wrap\n    //  around the screen edges, so when it goes off any side it should\n    //  re-appear on the opposite side.\n    this.headPosition.setTo(\n      Phaser.Math.Wrap(this.head.x + this.direction.x, 0, WIDTH * LENGTH),\n      Phaser.Math.Wrap(this.head.y + this.direction.y, 0, HEIGHT * LENGTH)\n    )\n\n    //  Update the body segments and place the last coordinate into\n    //  `this.tailPosition`.\n    Phaser.Actions.ShiftPosition(\n      this.body.children.entries,\n      this.headPosition.x,\n      this.headPosition.y,\n      1,\n      this.tailPosition\n    )\n\n    //  Check to see if any of the body pieces have the same x/y as the head.\n    //  If they do, the head ran into the body.\n    if (this.hitBody()) {\n      //  Game Over!\n      this.alive = false\n      return false\n    }\n\n    //  Update the timer ready for the next movement.\n    this.moveTime = time + this.moveDelay\n\n    return true\n  }\n\n  /**\n   *  Adds a new segment to the snake.\n   *\n   *  @private\n   */\n  grow() {\n    this.body.create(this.tailPosition.x, this.tailPosition.y)\n  }\n\n  /**\n   *  Checks if the snake has collided with a piece of food.\n   *\n   *  @public\n   *  @param {Food} food - A food sprite.\n   *  @param {number} points - The player scored points.\n   *  @returns {boolean} True if the snake collided, false otherwise.\n   */\n  collideWithFood(food, points) {\n    if (this.head.x === food.x && this.head.y === food.y) {\n      this.grow()\n\n      //  For every 5 pieces of food eaten we'll increase the snake speed a\n      //  little.\n      if (this.moveDelay > 20 && points % 25 === 0) {\n        this.moveDelay -= 5\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   *  Validates the positions on the grid where a new piece of food can be\n   *  placed.\n   *\n   *  @protected\n   *  @param {boolean.<array[]>} grid - A grid of positions to validate.\n   *  @returns {boolean.<array[]>} The updated grid.\n   */\n  updateGrid(grid) {\n    //  Remove all body pieces from valid positions list.\n    for (const segment of this.body.getChildren()) {\n      const x = segment.x / LENGTH\n      const y = segment.y / LENGTH\n\n      grid[y][x] = false\n    }\n\n    return grid\n  }\n}\n","import { WIDTH, HEIGHT, LENGTH } from '@/constants/grid';\nimport Food from '@/objects/food';\nimport Snake from '@/objects/snake';\n\nexport default class Maze extends Phaser.Scene {\n  /**\n   *  Where the actual game play happens. Control and logic updates are\n   *  handled by the Game scene, though.\n   *\n   *  @extends Phaser.Scene\n   */\n  constructor() {\n    super({\n      key: 'Maze',\n\n      //  Make the viewport an exact fit of the game board, giving a margin of\n      //  half the grid length (8px) around its edges.\n      cameras: [\n        {\n          x: LENGTH / 2,\n          y: 2 * LENGTH,\n          width: WIDTH * LENGTH,\n          height: HEIGHT * LENGTH\n        }\n      ]\n    });\n  }\n\n  //  ------------------------------------------------------------------------\n\n  /**\n   *  Add the food sprite at the given grid coordinates.\n   *\n   *  @protected\n   *  @param {number} [x=0] - The horizontal grid coordinate.\n   *  @param {number} [y=x] - The vetical grid coordinate.\n   *  @return {Food} The food sprite.\n   */\n  addFood(x = 0, y = x) {\n    return new Food(this, x, y);\n  }\n\n  /**\n   *  Add the snake group at the given grid coordinates.\n   *\n   *  @protected\n   *  @param {number} [x=0] - The horizontal grid coordinate.\n   *  @param {number} [y=x] - The vetical grid coordinate.\n   *  @return {Snake} The snake sprite.\n   */\n  addSnake(x = 0, y = 0) {\n    return new Snake(this, x, y);\n  }\n}\n","import { WIDTH, LENGTH } from '@/constants/grid';\nimport fontConfig from '@/constants/bitmap-fonts';\n\nexport default class Scoreboard extends Phaser.Scene {\n  /**\n   *  Shows the player scored points and the 'GAME OVER' message.\n   *\n   *  Upon initialization, it receives the host scene object and binds to its\n   *  emitted events to receive updates.\n   *\n   *  @extends Phaser.Scene\n   */\n  constructor() {\n    super({\n      key: 'Scoreboard',\n\n      //  Align the scene viewport to the top of the screen, with a margin of\n      //  half the length of the grid unit (8px) around its edges.\n      cameras: [\n        {\n          x: LENGTH / 2,\n          y: LENGTH / 2,\n          width: WIDTH * LENGTH,\n          height: LENGTH\n        }\n      ]\n    });\n  }\n\n  /**\n   *  Called when this scene is initialized.\n   *\n   *  @protected\n   *  @param {object} data - Initialization parameters.\n   *  @param {Game} data.gameScene - The host scene.\n   */\n  init({ gameScene }) {\n    //  Bind the maze events to update the score board.\n    gameScene.events\n      .on('food-eaten', points => this.setScore(points))\n      .on('snake-died', () => this.showGameOver());\n  }\n\n  /**\n   *  Responsible for setting up game objects on the screen.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  create(/* data */) {\n    //  Add the score numerals label.\n    this.scoreLabel = this.add.bitmapText(0, 0, fontConfig.image, '0');\n\n    //  Align this label to the right side.\n    this.gameOverLabel = this.add\n      .bitmapText(WIDTH * LENGTH, 0, fontConfig.image, 'GAME OVER')\n      .setOrigin(1, 0)\n      .setVisible(false);\n  }\n\n  //  -------------------------------------------------------------------------\n\n  /**\n   *  Updates the displayed game score.\n   *\n   *  @param {number} points - How many points the player scored.\n   *  @private\n   */\n  setScore(points) {\n    this.scoreLabel.setText(String(points));\n  }\n\n  /**\n   *  Displays the 'GAME OVER' message.\n   *\n   *  @private\n   */\n  showGameOver() {\n    this.gameOverLabel.setVisible(true);\n  }\n}\n","export default class ChooseName extends Phaser.Scene {\n  /**\n   *  Show the game title and menu.\n   *\n   *  @extends Phaser.Scene\n   */\n  constructor() {\n    super({ key: 'ChooseName' });\n  }\n\n  /**\n   *  Responsible for setting up the game objects on the screen.\n   *\n   *  @protected\n   *  @param {object} [data={}] - Initialization parameters.\n   */\n  create(/* data */) {\n    //  Save viewport center coordinates for reference.\n    const x = this.cameras.main.width / 2;\n    const y = this.cameras.main.height / 2;\n    //  Place the Title image above the middle of the screen.\n    //this.add.image(x, y - 80, 'title')\n\n    const message = this.add.bitmapText(\n      x - 120,\n      y - 60,\n      'font',\n      'ENTER YOUR NAME:'\n    );\n\n    let nameInput = document.getElementById('snakeName');\n    nameInput.style.display = 'block';\n\n    const submitBtn = this.add.bitmapText(x - 50, y + 60, 'font', 'SUBMIT');\n    this.add\n      .zone(\n        submitBtn.x - submitBtn.width * submitBtn.originX - 16,\n        submitBtn.y - submitBtn.height * submitBtn.originY - 16,\n        submitBtn.width + 32,\n        submitBtn.height + 32\n      )\n      .setOrigin(0, 0)\n      .setInteractive()\n      .once('pointerup', () => {\n        this.scene.stop('ChooseName');\n        this.scene.start('Game');\n        nameInput.style.display = 'none';\n      });\n  }\n}\n","/*\n *  `config` module\n *  ===============\n *\n *  The game instance settings.\n */\n\n//  Import created game scenes.\nimport * as scenes from '@/scenes';\n\n//  HINT: Import plugins, custom or trusted third-party ones, here.\n// import ExamplePlugin from 'example-plugin';\n// import ExampleScenePlugin from '@/plugins/example-scene-plugin';\n\n/**\n *  Game canvas width.\n */\nexport const width = 640;\n//export const width = window.screen.availWidth\n\n/**\n *  Game canvas height.\n */\nexport const height = 360;\n\n/**\n *  Adjust zoom factor.\n */\nexport const zoom = 1;\n\n/**\n *  Adjust pixel density of game graphics.\n */\nexport const resolution = 1;\n\n/**\n *  Choose a rendering method.\n *\n *  Available options are:\n *\n *    - `WEBGL`: Use WebGL rendering;\n *    - `CANVAS`: Use 'context2D' API rendering method;\n *    - `AUTO`: Phaser will choose, based on device capabilities, the best\n *      rendering method to be used.\n */\nexport const type = Phaser.AUTO;\n\n/**\n *  Whether to disable antialiasing or not. Great for pixel art.\n */\nexport const pixelArt = false;\n\n/**\n *  Whether to enable canvas transparency or not.\n */\nexport const transparent = false;\n\n/**\n *  Apply some style to the canvas element.\n */\nexport const canvasStyle = 'display: block; margin: 0 auto;';\n\n/**\n *  Define a default a background color.\n */\nexport const backgroundColor = '#bfcc00';\n\n/**\n *  Configure physics engines global parameters.\n *\n *  Available systems are:\n *\n *    - `arcade`: Phaser Arcade Physics 2;\n *    - `matter`: Liam Brummitt's (@liabru) Matter.js;\n *    - `impact`: ImpactJS Physics Engine.\n */\nexport const physics = {\n  /**\n   *  Phaser Arcade Physics 2 parameters.\n   *\n   *  This engine becomes available under a `physics` property on game scenes.\n   */\n  // arcade: {\n  // },\n\n  /**\n   *  Matter.js parameters.\n   *\n   *  This engine becomes available under a `matter` property on game scenes.\n   */\n  // matter: {\n  // },\n\n  /**\n   *  Impact Physics Engine parameters.\n   *\n   *  This engine becomes available under a `impact` property on game scenes.\n   */\n  // impact: {\n  // },\n\n  /**\n   *  Enable a physics engine by default on all game scenes.\n   */\n  default: false\n};\n\n/**\n *  Global parameters of the asset manager.\n */\nexport const loader = {\n  //  HINT: Put all your game assets in the `app/static/assets/` directory.\n  path: 'assets/'\n};\n\n/**\n *  Declare custom Phaser plugins.\n *\n *  There are two kinds of plugins: Global Plugins and Scene Plugins.\n *\n *  Global plugins are instantiated once per game and persist throughout the\n *  whole session.\n *\n *  Scene plugins are instantiated with each scene and are stored in the\n *  `Systems` class, rather than the global plugin manager. Scene plugins are\n *  tied to the scene life cycle.\n */\nexport const plugins = {\n  global: [\n    // {\n    //   //  An identifier to associate this plugin instance within Phaser's\n    //   //  plugin manager cache. It must be unique to avoid naming clashes\n    //   //  with other plugins.\n    //   key: 'ExamplePlugin',\n    //\n    //   //  The imported plugin class.\n    //   plugin: ExamplePlugin,\n    //\n    //   //  The property name your plugin will be aliased to. This plugin\n    //   //  will be exposed as a property of your scene context, for example,\n    //   //  `this.myPlugin`.\n    //   mapping: 'myPlugin',\n    //\n    //   //  Whether to start up or not this plugin on game's initialization.\n    //   //  If omitted or set to `false`, you must request the plugin manager\n    //   //  to start up the plugin on a game scene using the method\n    //   //  `this.plugins.start('<key>')`.\n    //   start: true\n    // },\n  ],\n\n  scene: [\n    // {\n    //   //  An identifier for reference in the scene `Systems` class. It must\n    //   //  be unique to avoid naming clashes with other plugins.\n    //   key: 'ExampleScenePlugin',\n    //\n    //   //  The imported plugin class.\n    //   plugin: ExampleScenePlugin,\n    //\n    //   //  The property name your plugin will be aliased to. This plugin\n    //   //  will be exposed as a property of your scene context, for example,\n    //   //  `this.myPlugin`.\n    //   mapping: 'myPlugin'\n    // }\n  ]\n};\n\n/**\n *  Export the game title, version and Web address, as defined in the\n *  project package metadata file (`package.json`).\n *\n *  These properties can be accessed in the game configuration object\n *  (`scene.sys.game.config`), under the keys `gameTitle`, `gameVersion` and\n *  `gameURL`, respectively.\n */\nexport { title, version, url } from '@/../../package.json';\n\n/**\n *  Export created game scenes.\n */\nexport const scene = Object.values(scenes);\n","/*\n *  `app` module\n *  ============\n *\n *  Provides the game initialization routine.\n */\n\n//  Import game instance configuration.\nimport * as config from '@/config';\n\n//  Boot the game.\nexport function boot() {\n  return new Phaser.Game(config);\n}\n\nboot();\n"],"sourceRoot":""}